{"version":3,"sources":["index.js","measure-text.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _path = _interopRequireDefault(require(\"path\"));\nvar _loadBmfont = _interopRequireDefault(require(\"load-bmfont\"));\nvar _utils = require(\"@jimp/utils\");\nvar _measureText = require(\"./measure-text\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction xOffsetBasedOnAlignment(constants, font, line, maxWidth, alignment) {\n  if (alignment === constants.HORIZONTAL_ALIGN_LEFT) {\n    return 0;\n  }\n  if (alignment === constants.HORIZONTAL_ALIGN_CENTER) {\n    return (maxWidth - (0, _measureText.measureText)(font, line)) / 2;\n  }\n  return maxWidth - (0, _measureText.measureText)(font, line);\n}\nfunction drawCharacter(image, font, x, y, char) {\n  if (char.width > 0 && char.height > 0) {\n    const characterPage = font.pages[char.page];\n    image.blit(characterPage, x + char.xoffset, y + char.yoffset, char.x, char.y, char.width, char.height);\n  }\n  return image;\n}\nfunction printText(font, x, y, text, defaultCharWidth) {\n  for (let i = 0; i < text.length; i++) {\n    let char;\n    if (font.chars[text[i]]) {\n      char = text[i];\n    } else if (/\\s/.test(text[i])) {\n      char = \"\";\n    } else {\n      char = \"?\";\n    }\n    const fontChar = font.chars[char] || {};\n    const fontKerning = font.kernings[char];\n    drawCharacter(this, font, x, y, fontChar || {});\n    const kerning = fontKerning && fontKerning[text[i + 1]] ? fontKerning[text[i + 1]] : 0;\n    x += kerning + (fontChar.xadvance || defaultCharWidth);\n  }\n}\nfunction loadPages(Jimp, dir, pages) {\n  const newPages = pages.map(page => {\n    return Jimp.read(dir + \"/\" + page);\n  });\n  return Promise.all(newPages);\n}\nconst dir = process.env.DIRNAME || `${__dirname}/../`;\nvar _default = () => ({\n  constants: {\n    measureText: _measureText.measureText,\n    measureTextHeight: _measureText.measureTextHeight,\n    FONT_SANS_8_BLACK: _path.default.join(dir, \"fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt\"),\n    FONT_SANS_10_BLACK: _path.default.join(dir, \"fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt\"),\n    FONT_SANS_12_BLACK: _path.default.join(dir, \"fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt\"),\n    FONT_SANS_14_BLACK: _path.default.join(dir, \"fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt\"),\n    FONT_SANS_16_BLACK: _path.default.join(dir, \"fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt\"),\n    FONT_SANS_32_BLACK: _path.default.join(dir, \"fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt\"),\n    FONT_SANS_64_BLACK: _path.default.join(dir, \"fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt\"),\n    FONT_SANS_128_BLACK: _path.default.join(dir, \"fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt\"),\n    FONT_SANS_8_WHITE: _path.default.join(dir, \"fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt\"),\n    FONT_SANS_16_WHITE: _path.default.join(dir, \"fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt\"),\n    FONT_SANS_32_WHITE: _path.default.join(dir, \"fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt\"),\n    FONT_SANS_64_WHITE: _path.default.join(dir, \"fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt\"),\n    FONT_SANS_128_WHITE: _path.default.join(dir, \"fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt\"),\n    /**\n     * Loads a bitmap font from a file\n     * @param {string} file the file path of a .fnt file\n     * @param {function(Error, Jimp)} cb (optional) a function to call when the font is loaded\n     * @returns {Promise} a promise\n     */\n    loadFont(file, cb) {\n      if (typeof file !== \"string\") return _utils.throwError.call(this, \"file must be a string\", cb);\n      return new Promise((resolve, reject) => {\n        cb = cb || function (err, font) {\n          if (err) reject(err);else resolve(font);\n        };\n        (0, _loadBmfont.default)(file, (err, font) => {\n          const chars = {};\n          const kernings = {};\n          if (err) {\n            return _utils.throwError.call(this, err, cb);\n          }\n          for (let i = 0; i < font.chars.length; i++) {\n            chars[String.fromCharCode(font.chars[i].id)] = font.chars[i];\n          }\n          for (let i = 0; i < font.kernings.length; i++) {\n            const firstString = String.fromCharCode(font.kernings[i].first);\n            kernings[firstString] = kernings[firstString] || {};\n            kernings[firstString][String.fromCharCode(font.kernings[i].second)] = font.kernings[i].amount;\n          }\n          loadPages(this, _path.default.dirname(file), font.pages).then(pages => {\n            cb(null, {\n              chars,\n              kernings,\n              pages,\n              common: font.common,\n              info: font.info\n            });\n          });\n        });\n      });\n    }\n  },\n  class: {\n    /**\n     * Draws a text on a image on a given boundary\n     * @param {Jimp} font a bitmap font loaded from `Jimp.loadFont` command\n     * @param {number} x the x position to start drawing the text\n     * @param {number} y the y position to start drawing the text\n     * @param {any} text the text to draw (string or object with `text`, `alignmentX`, and/or `alignmentY`)\n     * @param {number} maxWidth (optional) the boundary width to draw in\n     * @param {number} maxHeight (optional) the boundary height to draw in\n     * @param {function(Error, Jimp)} cb (optional) a function to call when the text is written\n     * @returns {Jimp} this for chaining of methods\n     */\n    print(font, x, y, text, maxWidth, maxHeight, cb) {\n      if (typeof maxWidth === \"function\" && typeof cb === \"undefined\") {\n        cb = maxWidth;\n        maxWidth = Infinity;\n      }\n      if (typeof maxWidth === \"undefined\") {\n        maxWidth = Infinity;\n      }\n      if (typeof maxHeight === \"function\" && typeof cb === \"undefined\") {\n        cb = maxHeight;\n        maxHeight = Infinity;\n      }\n      if (typeof maxHeight === \"undefined\") {\n        maxHeight = Infinity;\n      }\n      if (typeof font !== \"object\") {\n        return _utils.throwError.call(this, \"font must be a Jimp loadFont\", cb);\n      }\n      if (typeof x !== \"number\" || typeof y !== \"number\" || typeof maxWidth !== \"number\") {\n        return _utils.throwError.call(this, \"x, y and maxWidth must be numbers\", cb);\n      }\n      if (typeof maxWidth !== \"number\") {\n        return _utils.throwError.call(this, \"maxWidth must be a number\", cb);\n      }\n      if (typeof maxHeight !== \"number\") {\n        return _utils.throwError.call(this, \"maxHeight must be a number\", cb);\n      }\n      let alignmentX;\n      let alignmentY;\n      if (typeof text === \"object\" && text.text !== null && text.text !== undefined) {\n        alignmentX = text.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT;\n        alignmentY = text.alignmentY || this.constructor.VERTICAL_ALIGN_TOP;\n        ({\n          text\n        } = text);\n      } else {\n        alignmentX = this.constructor.HORIZONTAL_ALIGN_LEFT;\n        alignmentY = this.constructor.VERTICAL_ALIGN_TOP;\n        text = text.toString();\n      }\n      if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_BOTTOM) {\n        y += maxHeight - (0, _measureText.measureTextHeight)(font, text, maxWidth);\n      } else if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_MIDDLE) {\n        y += maxHeight / 2 - (0, _measureText.measureTextHeight)(font, text, maxWidth) / 2;\n      }\n      const defaultCharWidth = Object.entries(font.chars)[0][1].xadvance;\n      const {\n        lines,\n        longestLine\n      } = (0, _measureText.splitLines)(font, text, maxWidth);\n      lines.forEach(line => {\n        const lineString = line.join(\" \");\n        const alignmentWidth = xOffsetBasedOnAlignment(this.constructor, font, lineString, maxWidth, alignmentX);\n        printText.call(this, font, x + alignmentWidth, y, lineString, defaultCharWidth);\n        y += font.common.lineHeight;\n      });\n      if ((0, _utils.isNodePattern)(cb)) {\n        cb.call(this, null, this, {\n          x: x + longestLine,\n          y\n        });\n      }\n      return this;\n    }\n  }\n});\nexports.default = _default;\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;\n//# sourceMappingURL=index.js.map","\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.measureText = measureText;\nexports.measureTextHeight = measureTextHeight;\nexports.splitLines = splitLines;\nfunction measureText(font, text) {\n  let x = 0;\n  for (let i = 0; i < text.length; i++) {\n    if (font.chars[text[i]]) {\n      const kerning = font.kernings[text[i]] && font.kernings[text[i]][text[i + 1]] ? font.kernings[text[i]][text[i + 1]] : 0;\n      x += (font.chars[text[i]].xadvance || 0) + kerning;\n    }\n  }\n  return x;\n}\nfunction splitLines(font, text, maxWidth) {\n  const words = text.replace(/[\\r\\n]+/g, \" \\n\").split(\" \");\n  const lines = [];\n  let currentLine = [];\n  let longestLine = 0;\n  words.forEach(word => {\n    const line = [...currentLine, word].join(\" \");\n    const length = measureText(font, line);\n    if (length <= maxWidth && !word.includes(\"\\n\")) {\n      if (length > longestLine) {\n        longestLine = length;\n      }\n      currentLine.push(word);\n    } else {\n      lines.push(currentLine);\n      currentLine = [word.replace(\"\\n\", \"\")];\n    }\n  });\n  lines.push(currentLine);\n  return {\n    lines,\n    longestLine\n  };\n}\nfunction measureTextHeight(font, text, maxWidth) {\n  const {\n    lines\n  } = splitLines(font, text, maxWidth);\n  return lines.length * font.common.lineHeight;\n}\n//# sourceMappingURL=measure-text.js.map"]}