{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _utils = require(\"@jimp/utils\");\n/**\n * Rotates an image counter-clockwise by multiple of 90 degrees. NB: 'this' must be a Jimp object.\n *\n * This function is based on matrix rotation. Check this to get an initial idea how it works: https://stackoverflow.com/a/8664879/10561909\n *\n * @param {number} deg the number of degrees to rotate the image by, it should be a multiple of 90\n */\nfunction matrixRotate(deg) {\n  if (Math.abs(deg) % 90 !== 0) {\n    throw new Error(\"Unsupported matrix rotation degree\");\n  }\n  deg %= 360;\n  if (Math.abs(deg) === 0) {\n    // no rotation for 0, 360, -360, 720, -720, ...\n    return;\n  }\n  const w = this.bitmap.width;\n  const h = this.bitmap.height;\n\n  // decide which rotation angle to use\n  let angle;\n  switch (deg) {\n    // 90 degree & -270 degree are same\n    case 90:\n    case -270:\n      angle = 90;\n      break;\n    case 180:\n    case -180:\n      angle = 180;\n      break;\n    case 270:\n    case -90:\n      angle = -90;\n      break;\n    default:\n      throw new Error(\"Unsupported matrix rotation degree\");\n  }\n  // After this switch block, angle will be 90, 180 or -90\n\n  // calculate the new width and height\n  const nW = angle === 180 ? w : h;\n  const nH = angle === 180 ? h : w;\n  const dstBuffer = Buffer.alloc(this.bitmap.data.length);\n\n  // function to translate the x, y coordinate to the index of the pixel in the buffer\n  function createIdxTranslationFunction(w, h) {\n    return function (x, y) {\n      return y * w + x << 2;\n    };\n  }\n  const srcIdxFunction = createIdxTranslationFunction(w, h);\n  const dstIdxFunction = createIdxTranslationFunction(nW, nH);\n  for (let x = 0; x < w; x++) {\n    for (let y = 0; y < h; y++) {\n      const srcIdx = srcIdxFunction(x, y);\n      const pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);\n      let dstIdx;\n      switch (angle) {\n        case 90:\n          dstIdx = dstIdxFunction(y, w - x - 1);\n          break;\n        case -90:\n          dstIdx = dstIdxFunction(h - y - 1, x);\n          break;\n        case 180:\n          dstIdx = dstIdxFunction(w - x - 1, h - y - 1);\n          break;\n        default:\n          throw new Error(\"Unsupported matrix rotation angle\");\n      }\n      dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);\n    }\n  }\n  this.bitmap.data = dstBuffer;\n  this.bitmap.width = nW;\n  this.bitmap.height = nH;\n}\n\n/**\n * Rotates an image counter-clockwise by an arbitrary number of degrees. NB: 'this' must be a Jimp object.\n * @param {number} deg the number of degrees to rotate the image by\n * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n */\nfunction advancedRotate(deg, mode) {\n  deg %= 360;\n  const rad = deg * Math.PI / 180;\n  const cosine = Math.cos(rad);\n  const sine = Math.sin(rad);\n\n  // the final width and height will change if resize == true\n  let w = this.bitmap.width;\n  let h = this.bitmap.height;\n  if (mode === true || typeof mode === \"string\") {\n    // resize the image to it maximum dimension and blit the existing image\n    // onto the center so that when it is rotated the image is kept in bounds\n\n    // http://stackoverflow.com/questions/3231176/how-to-get-size-of-a-rotated-rectangle\n    // Plus 1 border pixel to ensure to show all rotated result for some cases.\n    w = Math.ceil(Math.abs(this.bitmap.width * cosine) + Math.abs(this.bitmap.height * sine)) + 1;\n    h = Math.ceil(Math.abs(this.bitmap.width * sine) + Math.abs(this.bitmap.height * cosine)) + 1;\n    // Ensure destination to have even size to a better result.\n    if (w % 2 !== 0) {\n      w++;\n    }\n    if (h % 2 !== 0) {\n      h++;\n    }\n    const c = this.cloneQuiet();\n    this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function (x, y, idx) {\n      this.bitmap.data.writeUInt32BE(this._background, idx);\n    });\n    const max = Math.max(w, h, this.bitmap.width, this.bitmap.height);\n    this.resize(max, max, mode);\n    this.blit(c, this.bitmap.width / 2 - c.bitmap.width / 2, this.bitmap.height / 2 - c.bitmap.height / 2);\n  }\n  const bW = this.bitmap.width;\n  const bH = this.bitmap.height;\n  const dstBuffer = Buffer.alloc(this.bitmap.data.length);\n  function createTranslationFunction(deltaX, deltaY) {\n    return function (x, y) {\n      return {\n        x: x + deltaX,\n        y: y + deltaY\n      };\n    };\n  }\n  const translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));\n  const translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);\n  for (let y = 1; y <= bH; y++) {\n    for (let x = 1; x <= bW; x++) {\n      const cartesian = translate2Cartesian(x, y);\n      const source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);\n      const dstIdx = bW * (y - 1) + x - 1 << 2;\n      if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {\n        const srcIdx = (bW * (source.y | 0) + source.x | 0) << 2;\n        const pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);\n        dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);\n      } else {\n        // reset off-image pixels\n        dstBuffer.writeUInt32BE(this._background, dstIdx);\n      }\n    }\n  }\n  this.bitmap.data = dstBuffer;\n  if (mode === true || typeof mode === \"string\") {\n    // now crop the image to the final size\n    const x = bW / 2 - w / 2;\n    const y = bH / 2 - h / 2;\n    this.crop(x, y, w, h);\n  }\n}\nvar _default = () => ({\n  /**\n   * Rotates the image counter-clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.\n   * @param {number} deg the number of degrees to rotate the image by\n   * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed\n   * @param {function(Error, Jimp)} cb (optional) a callback for when complete\n   * @returns {Jimp} this for chaining of methods\n   */\n  rotate(deg, mode, cb) {\n    // enable overloading\n    if (typeof mode === \"undefined\" || mode === null) {\n      // e.g. image.resize(120);\n      // e.g. image.resize(120, null, cb);\n      // e.g. image.resize(120, undefined, cb);\n      mode = true;\n    }\n    if (typeof mode === \"function\" && typeof cb === \"undefined\") {\n      // e.g. image.resize(120, cb);\n      cb = mode;\n      mode = true;\n    }\n    if (typeof deg !== \"number\") {\n      return _utils.throwError.call(this, \"deg must be a number\", cb);\n    }\n    if (typeof mode !== \"boolean\" && typeof mode !== \"string\") {\n      return _utils.throwError.call(this, \"mode must be a boolean or a string\", cb);\n    }\n\n    // use matrixRotate if the angle is a multiple of 90 degrees (eg: 180 or -90) and resize is allowed or not needed.\n    const matrixRotateAllowed = deg % 90 === 0 && (mode || this.bitmap.width === this.bitmap.height || deg % 180 === 0);\n    if (matrixRotateAllowed) {\n      matrixRotate.call(this, deg);\n    } else {\n      advancedRotate.call(this, deg, mode, cb);\n    }\n    if ((0, _utils.isNodePattern)(cb)) {\n      cb.call(this, null, this);\n    }\n    return this;\n  }\n});\nexports.default = _default;\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;\n//# sourceMappingURL=index.js.map"]}